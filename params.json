{"name":"Gwt-appcache","tagline":"GWT AppCache Support Library","body":"gwt-appcache\r\n============\r\n\r\n[![Build Status](https://secure.travis-ci.org/realityforge/gwt-appcache.png?branch=master)](http://travis-ci.org/realityforge/gwt-appcache)\r\n\r\nThe HTML5 Appcache specification is a mechanism for enabling offline\r\nHTML5 applications. This library provides a simple way to generate the\r\nrequired cache manifests and serve a separate manifest for each separate\r\npermutation. The library also provides support for the browser side aspects\r\nof the appcache specification. See the appendix section includes further\r\nreferences concerning the appcache spec.\r\n\r\nQuick Start\r\n-----------\r\n\r\nThe simplest way to appcache enable a GWT application is to;\r\n\r\n* add the following dependencies into the build system. i.e.\r\n\r\n```xml\r\n<dependency>\r\n   <groupId>org.realityforge.gwt.appcache</groupId>\r\n   <artifactId>gwt-appcache-client</artifactId>\r\n   <version>1.0.7</version>\r\n   <scope>provided</scope>\r\n</dependency>\r\n<dependency>\r\n   <groupId>org.realityforge.gwt.appcache</groupId>\r\n   <artifactId>gwt-appcache-linker</artifactId>\r\n   <version>1.0.7</version>\r\n   <scope>provided</scope>\r\n</dependency>\r\n<dependency>\r\n   <groupId>org.realityforge.gwt.appcache</groupId>\r\n   <artifactId>gwt-appcache-server</artifactId>\r\n   <version>1.0.7</version>\r\n</dependency>\r\n```\r\n\r\n* add the following snippet into the .gwt.xml file.\r\n\r\n```xml\r\n<module rename-to='myapp'>\r\n  ...\r\n\r\n  <!-- Enable the client-side library -->\r\n  <inherits name=\"org.realityforge.gwt.appcache.Appcache\"/>\r\n\r\n  <!-- Enable the linker -->\r\n  <inherits name=\"org.realityforge.gwt.appcache.linker.Linker\"/>\r\n\r\n  <!-- enable the linker that generates the manifest -->\r\n  <add-linker name=\"appcache\"/>\r\n\r\n  <!-- configure all the static files not managed by the GWT compiler -->\r\n  <extend-configuration-property name=\"appcache_static_files\" value=\"./\"/>\r\n  <extend-configuration-property name=\"appcache_static_files\" value=\"index.html\"/>\r\n\r\n  <!-- configure fallback rules used by the client when offline -->\r\n  <extend-configuration-property name=\"appcache_fallback_files\" value=\"online.png offline.png\"/>\r\n  <extend-configuration-property name=\"appcache_fallback_files\" value=\"myDynamicService.jsp  myOfflineData.json\"/>\r\n</module>\r\n```\r\n\r\n* configure html that launches the application to look for the manifest.\r\n\r\n```xml\r\n<!doctype html>\r\n<html manifest=\"myapp.appcache\">\r\n   ...\r\n</html>\r\n```\r\n\r\n* declare the servlet that serves the manifest.\r\n\r\n```java\r\n@WebServlet( urlPatterns = { \"/myapp.appcache\" } )\r\npublic class ManifestServlet\r\n  extends AbstractManifestServlet\r\n{\r\n  public ManifestServlet()\r\n  {\r\n    addPropertyProvider( new UserAgentPropertyProvider() );\r\n  }\r\n}\r\n```\r\n\r\n* interact with the application from within the browser.\r\n\r\n```java\r\nfinal ApplicationCache cache = ApplicationCache.getApplicationCacheIfSupported();\r\nif ( null != cache )\r\n{\r\n  cache.addUpdateReadyHandler( new UpdateReadyEvent.Handler()\r\n  {\r\n    @Override\r\n    public void onUpdateReadyEvent( @Nonnull final UpdateReadyEvent event )\r\n    {\r\n      //Force a cache update if new version is available\r\n      cache.swapCache();\r\n    }\r\n  } );\r\n\r\n  // Ask the browser to recheck the cache\r\n  cache.requestUpdate();\r\n\r\n  ...\r\n```\r\n\r\n\r\nThis should be sufficient to get your application using the appcache. If you\r\nload the application in a modern browser you should see it making use of the\r\ncache in the console.\r\n\r\nA very simple example of this code is available in the\r\n[gwt-appcache-example](https://github.com/realityforge/gwt-appcache-example)\r\nproject.\r\n\r\nHow does it work?\r\n-----------------\r\n\r\nFor every permutation generated by the GWT compiler, a separate manifest file\r\nis generated. The manifest includes almost all public resources generated by\r\nGWT with the exception of some used during debugging and development (i.e.\r\n`myapp.devmode.js` and `compilation-mappings.txt`). The manifest also includes\r\nany additional files declared using the \"`appcache_static_files`\" configuration\r\nsetting. (It should be noted that the \"`appcache_static_files`\" files are\r\nrelative to the manifest file).\r\n\r\nAfter the GWT compiler has generated all the different permutations, a single\r\nxml descriptor `permutations.xml` is generated that lists all the permutations\r\nand the  deferred-binding properties that were used to uniquely identify the\r\npermutations. Typically these include values of properties such as \"`user.agent`\".\r\n\r\nIf the compiler is using soft permutations then it is possible that multiple\r\ndeferred-binding properties will be served using a single permutation, in which\r\ncase the descriptor will have comma separated values in the `permutations.xml`\r\nfor that permutation.\r\n\r\nThe manifest servlet is then responsible for reading the `permutations.xml` and\r\ninspecting the incoming request and generating properties that enable it to select\r\nthe correct permutation and thus the correct manifest file. The selected manifest\r\nfile is returned to the requester.\r\n\r\nHow To: Define a new Selection Configuration\r\n--------------------------------------------\r\n\r\nSometimes it is useful to define a new configuration property in the gwt module\r\ndescriptors that will define new permutations. A fairly typical example would\r\nbe to define a configuration property that defines different view modalities.\r\ni.e. Is the device phone-like, tablet-like or a desktop. This would drive the\r\nui and workflow in the application.\r\n\r\nStep 1 is to define the configuration in the gwt module descriptor. i.e.\r\n\r\n```xml\r\n<define-property name=\"ui.modality\" values=\"phone, tablet, desktop\"/>\r\n  <property-provider name=\"ui.modality\"><![CDATA[\r\n  {\r\n    var ua = window.navigator.userAgent.toLowerCase();\r\n    if ( ua.indexOf('android') != -1 ) { return 'phone'; }\r\n    if ( ua.indexOf('iphone') != -1 ) { return 'phone'; }\r\n    if ( ua.indexOf('ipad') != -1 ) { return 'tablet'; }\r\n    return 'desktop';\r\n  }\r\n]]></property-provider>\r\n```\r\n\r\nStep 2 is to use the new configuration property to control the deferred binding\r\nrules in gwt modules. For example, the following could be added to a .gwt.xml\r\nmodule file;\r\n\r\n```xml\r\n<replace-with class=\"com.biz.client.gin.DesktopInjectorWrapper\">\r\n  <when-type-is class=\"com.biz.client.gin.InjectorWrapper\"/>\r\n  <when-property-is name=\"ui.modality\" value=\"desktop\"/>\r\n</replace-with>\r\n\r\n<replace-with class=\"com.biz.client.gin.TabletInjectorWrapper\">\r\n  <when-type-is class=\"com.biz.client.gin.InjectorWrapper\"/>\r\n  <when-property-is name=\"ui.modality\" value=\"tablet\"/>\r\n</replace-with>\r\n\r\n<replace-with class=\"com.biz.client.gin.PhoneInjectorWrapper\">\r\n  <when-type-is class=\"com.biz.client.gin.InjectorWrapper\"/>\r\n  <when-property-is name=\"ui.modality\" value=\"phone\"/>\r\n</replace-with>\r\n```\r\n\r\nStep 3 is to define a property provider for your new configuration property and\r\nadd it to the manifest servlet. i.e.\r\n\r\n```java\r\npublic class UIModalityPropertyProvider\r\n  implements PropertyProvider\r\n{\r\n  @Override\r\n  public String getPropertyValue( final HttpServletRequest request )\r\n  {\r\n    final String ua = request.getHeader( \"User-Agent\" ).toLowerCase();\r\n    if ( ua.contains( \"android\" ) || ua.contains( \"phone\" ) ) { return \"phone\"; }\r\n    else if ( ua.contains( \"ipad\" ) ) { return \"tablet\"; }\r\n    else { return \"desktop\"; }\r\n  }\r\n\r\n  @Override\r\n  public String getPropertyName()\r\n  {\r\n    return \"ui.modality\";\r\n  }\r\n}\r\n```\r\n\r\n```java\r\n@WebServlet( urlPatterns = { \"/myapp.appcache\" } )\r\npublic class ManifestServlet\r\n  extends AbstractManifestServlet\r\n{\r\n  public ManifestServlet()\r\n  {\r\n    addPropertyProvider( new UIModalityPropertyProvider() );\r\n    addPropertyProvider( new UserAgentPropertyProvider() );\r\n  }\r\n}\r\n```\r\n\r\nThis example demonstrates a simple mechanism for supporting server-side derivable\r\nconfiguration properties to select a permutation. In some cases, the selection\r\nproperty can only be determined on the client. This scenario is more complex and\r\nrequires a combination of cookies and dynamic host pages to address.\r\n\r\nHow To: Define a new client-side selection Configuration\r\n--------------------------------------------------------\r\n\r\nSometimes configuration properties can only be determined on the client. A good\r\nexample is the device pixel density that can be determined by inspecting the\r\n\"window.devicePixelRatio\" property in the browser.\r\n\r\n```xml\r\n<define-property name=\"pixel.density\" values=\"high, low\"/>\r\n  <property-provider name=\"pixel.density\"><![CDATA[\r\n  {\r\n  if(window.devicePixelRatio >= 2) { return 'high'; }\r\n  return 'low';\r\n  }\r\n]]></property-provider>\r\n```\r\n\r\nThe gwt-appcache library can defer the selection of the property to the client-side\r\nby merging the manifests of the high and low density permutations and returning\r\nthe merged manifest to the client. This is done by marking the \"pixel.density\"\r\n property as client-side via;\r\n\r\n```java\r\n@WebServlet( urlPatterns = { \"/myapp.appcache\" } )\r\npublic class ManifestServlet\r\n  extends AbstractManifestServlet\r\n{\r\n  public ManifestServlet()\r\n  {\r\n    addPropertyProvider( new UserAgentPropertyProvider() );\r\n    ...\r\n    addClientSideSelectionProperty( \"pixel.density\" );\r\n  }\r\n}\r\n```\r\n\r\nThis will mean that the client ultimately caches extra data that may not be used\r\nby the client. This may be acceptable for small applications but a better approach\r\nis to detect the pixel density and set a cookie prior to navigating to the page\r\nthat hosts the application. The server can then attempt to determine the value of\r\nthe configuration property using the cookie name like;\r\n\r\n\r\n```java\r\npublic class PixelDensityPropertyProvider\r\n  implements PropertyProvider\r\n{\r\n  @Override\r\n  public String getPropertyName() { return \"pixel.density\"; }\r\n\r\n  @Override\r\n  public String getPropertyValue( HttpServletRequest request )\r\n  {\r\n    final Cookie[] cookies = request.getCookies();\r\n    if ( null != cookies )\r\n    {\r\n      for ( final Cookie cookie : cookies )\r\n      {\r\n        if ( \"pixel.density\".equals( cookie.getName() ) )\r\n        {\r\n          return cookie.getValue();\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n}\r\n```\r\n\r\n```java\r\n@WebServlet( urlPatterns = { \"/myapp.appcache\" } )\r\npublic class ManifestServlet\r\n  extends AbstractManifestServlet\r\n{\r\n  public ManifestServlet()\r\n  {\r\n    addPropertyProvider( new UserAgentPropertyProvider() );\r\n    addPropertyProvider( new PixelDensityPropertyProvider() );\r\n    ...\r\n    addClientSideSelectionProperty( \"pixel.density\" );\r\n  }\r\n}\r\n```\r\n\r\nHow To: Integrate into existing framework\r\n-----------------------------------------\r\n\r\nThe gwt-appcache library was designed to be easy to integrate into any other\r\ngwt framework. A good example is the wonderful [MGWT](https://github.com/dankurka/mgwt)\r\nlibrary from which this project was initially derived. MGWT selects the permutation\r\nbased on the following configuration properties;\r\n\r\n* `mgwt.os` - `iphone`, `iphone_retina`, `ipad`, `ipad_retina`, `android`, `android_tablet`, `blackberry` etc.\r\n* `mobile.user.agent` - `mobilesafari` vs `not_mobile`.\r\n* `user.agent` - A standard gwt configuration property.\r\n* `phonegap.env` - Always `no` for web applications.\r\n\r\nIt is important to the MGWT framework to distinguish between retina and non-retina versions of\r\nthe iphone and ipad variants. The retina versions inspect the `window.devicePixelRatio` browser property\r\nsimilarly to the above `pixel.density` example. Rather than making this a separate configuration\r\nproperty, MGWT conflates this with operating system. As a result it uses a custom strategy to\r\nmerge the multiple permutations manifests as can be observed at [AbstractMgwtManifestServlet](https://github.com/realityforge/gwt-appcache/blob/master/server/src/main/java/org/realityforge/gwt/appcache/server/mgwt/AbstractMgwtManifestServlet.java#L15-L62).\r\nMGWT also defines several [property providers](https://github.com/realityforge/gwt-appcache/tree/master/server/src/main/java/org/realityforge/gwt/appcache/server/mgwt).\r\nThere is a [pull request](https://github.com/dankurka/mgwt/pull/37) where you can look at the\r\nwork required to re-integrate the functionality back into the MGWT framework. This is a good\r\nexample of complex integration of `gwt-appcache`.\r\n\r\nHow To: Configure the url for the Manifest servlet in web.xml\r\n-------------------------------------------------------------\r\n\r\nThe above examples assume that annotations are used to configure the url for the manifest servlet. It\r\nis also possible to explicitly configure the url pattern in web.xml via a snippet similar to the\r\nfollowing. This will configure the appcache manifest to be at the path \"/somedir/example.appcache\"\r\nrelative to the application root. The manifest servlet will expect to find the permutations.xml file\r\nat the path \"/somedir/example/permutations.xml\" relative to the application root.\r\n\r\n```xml\r\n  <servlet>\r\n    <servlet-name>org.realityforge.gwt.appcache.example.server.ManifestServlet</servlet-name>\r\n  </servlet>\r\n\r\n  <servlet-mapping>\r\n    <servlet-name>org.realityforge.gwt.appcache.example.server.ManifestServlet</servlet-name>\r\n    <url-pattern>/somedir/example.appcache</url-pattern>\r\n  </servlet-mapping>\r\n```\r\n\r\nFrequently Asked Questions\r\n--------------------------\r\n\r\n### Why do I get a 404 from the Manifest servlet when I specify a configuration property in .gwt.xml?\r\n\r\nIf you specify a configuration property in your .gwt.xml file such as below, the manifest servlet may\r\nstart returning a 404. Why is this and how do I fix it?\r\n\r\n```xml\r\n  <set-property name=\"user.agent\" value=\"safari\" />\r\n```\r\n\r\nThe Manifest servlet uses the permutations.xml to determine how to select the permutation(s)\r\nto serve. The properties generated by the PropertyProvider instances added to the manifest must\r\nmatch the set of properties that are in the permutations.xml. If you add a property provider\r\nthat generates a property that is not present in permutations.xml then the manifest servlet will\r\nnever be able to find a permutation that matches that property and thus a 404 will be returned.\r\n\r\nWhen you specified a single value for the user.agent property above, the user.agent configuration was\r\nmade into a constant and thus it could not be used to distinguish between permutations. As a result, the\r\nproperty no longer appears in the permutations.xml file. At this point it is necessary to remove the\r\nUserAgentPropertyProvider from the manifest servlet.\r\n\r\nAppendix\r\n--------\r\n\r\n* [A Beginner's Guide to Using the Application Cache](http://www.html5rocks.com/en/tutorials/appcache/beginner/)\r\n* [Appcache Facts](http://appcachefacts.info/)\r\n* [Offline Web Application Standard](http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html)\r\n\r\nCredit\r\n------\r\n\r\nThis library began as a enhancement of similar functionality in the\r\n[MGWT](https://github.com/dankurka/mgwt) project by Daniel Kurka. All\r\ncredit goes to Daniel for the initial code and idea. The library is also\r\ninspired by work done by the [rebar](https://github.com/bedatadriven/rebar)\r\nproject. Thanks goes out to them as well.\r\n","google":"UA-41755265-2","note":"Don't delete this file! It's used internally to help with page regeneration."}